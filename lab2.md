## Lab2

---

### Overview

在Lab0中，您实现了流控制的字节流（ByteStream）的抽象;在Lab1中，您创建了一个StreamReassembler，该流接受来自同一字节流的所有子串序列，然后将它们重新组装回原始流。

这些模块将在你的后续的TCP实现中被证明是有用的，虽然这些模块不是传输控制协议所特有的细节。但是在之后的实验我们将了解传输控制协议的一些特有的细节，在Lab2中，我们将实现TCPReceiver，这是TCP中实现处理传入字节流的部分。 TCP接收器在传入的TCP段（通过Internet承载的数据报的有效载荷）和传入的字节流之间进行转换。

这是上一个实验的示意图。 TCPReceiver接收来自Internet的段（通过segment_received（）方法），并将其转换为对StreamReassembler的调用，最终将其写入传入的ByteStream。 应用程序从ByteStream读取，就像在Lab 0中通过从TCPSocket读取一样。

![](img-lab2\lab2-img-1.png)

除了写入传入流外，TCP接收器还负责告知发送方两件事：

1. “第一个未汇编”字节的索引，称为“确认号”或“ ackno”。 这是接收方需要发送方发送的第一个字节。
2. “第一个未组装的”索引和“第一个不可接受的”索引之间的距离。这称为“窗口大小”。

**ackno**和**window size**一起描述了接收者的窗口：允许TCP发送者发送的一系列索引。 接收者可以使用该窗口控制传入数据的流，使发送者限制发送的数据量，直到接收者准备好接收更多数据为止。 有时我们将ackno称为窗口的“左边缘”（TCPReceiveris感兴趣的最小索引），将ackno +窗口大小称为“右边缘”（仅超出TCPReceiveris感兴趣的最大索引）。

在编写StreamReassembler和ByteStream时，我们已经完成了实现TCPReceiver的大部分算法工作； 本Lab是关于将这些通用类连接到TCP的详细信息。 最困难的部分将涉及考虑TCP如何表示流中每个字节的位置（称为“序列号（sequence number）”）。

---

### Getting started

按照文档操作即可。

---

### Lab 2: The TCP Receiver

TCP是一种协议，它通过不可靠的数据报可靠地传送一对流控制的字节流（每个方向一个）。 有两个参与方参与TCP连接，并且每个参与方同时充当“发送方”（属于其自己的输出字节流）和“接收方”（属于传入的字节流）。 这两方称为连接的“端点”或“对等”。

这周，您将实现TCP的“接收器”部分，负责接收TCP段（实际的数据报有效载荷），重新组合字节流（包括字节流的结尾，发生时），并确定应将信号发送回 发送方的确认和流量控制。

> 我为什么要这样做？这些信号对于TCP在不可靠的数据报网络上提供流控制，可靠的字节流服务的能力至关重要。 在TCP中，确认表示：“接收器需要多少个下一个字节的索引，以便接收器可以重组更多的ByteStream？” 这告诉发送者它需要发送或重新发送什么字节。流控制意味着，“接收者感兴趣并愿意接收什么范围的索引？” （通常是其剩余容量的函数）。它告诉发件人可以发送多少。

#### ranslating between 64-bit indexes and 32-bit seqnos

作为热身，我们需要实现TCP表示索引的方式。 上周，我们创建了一个StreamReassembler，用于重新组装子字符串，其中每个单独的字节都有一个64位流的索引，而流中的第一个字节始终具有零索引。 64位索引足够大，我们可以将其视为永不溢出（以每秒100吉比特/秒的速度传输，要花费近50年才能达到$2^{64}$bytes。 相比之下，仅需三分之一的时间即可达到$2^{32}$bytes。）。但是，在TCP头中，空间非常宝贵，并且流中每个字节的索引不是用64位索引表示，而是用32位“序列”表示 数字”或“ seqno”。 这增加了三个复杂的地方：

1. **你需要实现一个环状的32位的编码系统。**TCP中的流可以任意长——这意味着可以通过TCP发送的ByteStream的长度没有限制。 但是$2^{32}$bytes只有4 GiB，不是很大。 所以一旦32位序列号计数到$2^{32}-1$，流中的下一个字节将具有0的序列号。
2. **TCP开始的序列号是随机值**：为了提高安全性并避免混淆属于相同端点之间较早连接的旧段，TCP尝试确保不会猜测序列号并且不太可能重复。 因此，流的序号不是从零开始。 流中的第一个序列号是称为初始序列号（ISN）的32位随机数。 这是代表SYN（流开始）的序列号，其余序列号在此之后正常运行：数据的第一个字节将具有ISN + 1的序列号（mod $2^{32}$），第二个字节将具有 ISN + 2（mod $2^{32}$）等。
3. **逻辑开始和结束分别占据一个序列号:**除了确保接收所有数据字节外，TCP还确保可靠地接收流的开始和结束。 因此，在TCP中，为SYN（流开始）和FIN（流结束）控制标志分配了序列号。 这些每个占用一个序列号。 （SYN标志占用的序列号是ISN。）流中的每个数据字节也占用一个序列号。 请记住，SYN和FIN不是流本身的一部分，也不是“字节”，它们代表字节流本身的开始和结束。

这些序列号（seqnos）在每个TCP段的头中被发送。 （而且，又有两个流，每个方向上都有一个。每个流具有单独的序列号和不同的随机ISN。）有时谈论“绝对序列号”（总是从零开始，不会换行），和大约一个“流索引”（您已经在streamReassembler中使用的内容：流中每个字节的索引，从零开始）。

了使这些区别更具体，请考虑仅包含三个字母字符串“ cat”的字节流。 如果SYN恰好具有seqno $2^{32}-2$，则每个字节的seqnos，绝对seqnos和流索引为：

| 元素    | `SYN`      | c          | a    | t    | `FIN` |
| ------- | ---------- | ---------- | ---- | ---- | ----- |
| seqno   | $2^{32}-2$ | $2^{32}-1$ | $0$  | $1$  | $2$   |
| 绝对seq | $0$        | $1$        | $2$  | $3$  | $4$   |
| 流索引  |            | $0$        | $1$  | $2$  |       |

 该图显示了TCP中涉及的三种不同类型的索引编制:




