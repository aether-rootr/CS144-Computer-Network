## Lab2

---

### Overview

在Lab0中，您实现了流控制的字节流（ByteStream）的抽象;在Lab1中，您创建了一个StreamReassembler，该流接受来自同一字节流的所有子串序列，然后将它们重新组装回原始流。

这些模块将在你的后续的TCP实现中被证明是有用的，虽然这些模块不是传输控制协议所特有的细节。但是在之后的实验我们将了解传输控制协议的一些特有的细节，在Lab2中，我们将实现TCPReceiver，这是TCP中实现处理传入字节流的部分。 TCP接收器在传入的TCP段（通过Internet承载的数据报的有效载荷）和传入的字节流之间进行转换。

这是上一个实验的示意图。 TCPReceiver接收来自Internet的段（通过segment_received（）方法），并将其转换为对StreamReassembler的调用，最终将其写入传入的ByteStream。 应用程序从ByteStream读取，就像在Lab 0中通过从TCPSocket读取一样。

![](img-lab2\lab2-img-1.png)

除了写入传入流外，TCP接收器还负责告知发送方两件事：

1. “第一个未汇编”字节的索引，称为“确认号”或“ ackno”。 这是接收方需要发送方发送的第一个字节。
2. “第一个未组装的”索引和“第一个不可接受的”索引之间的距离。这称为“窗口大小”。

**ackno**和**window size**一起描述了接收者的窗口：允许TCP发送者发送的一系列索引。 接收者可以使用该窗口控制传入数据的流，使发送者限制发送的数据量，直到接收者准备好接收更多数据为止。 有时我们将ackno称为窗口的“左边缘”（TCPReceiveris感兴趣的最小索引），将ackno +窗口大小称为“右边缘”（仅超出TCPReceiveris感兴趣的最大索引）。

在编写StreamReassembler和ByteStream时，我们已经完成了实现TCPReceiver的大部分算法工作； 本Lab是关于将这些通用类连接到TCP的详细信息。 最困难的部分将涉及考虑TCP如何表示流中每个字节的位置（称为“序列号（sequence number）”）。

---

### Getting started

按照文档操作即可。

---

### Lab 2: The TCP Receiver

TCP是一种协议，它通过不可靠的数据报可靠地传送一对流控制的字节流（每个方向一个）。 有两个参与方参与TCP连接，并且每个参与方同时充当“发送方”（属于其自己的输出字节流）和“接收方”（属于传入的字节流）。 这两方称为连接的“端点”或“对等”。

这周，您将实现TCP的“接收器”部分，负责接收TCP段（实际的数据报有效载荷），重新组合字节流（包括字节流的结尾，发生时），并确定应将信号发送回 发送方的确认和流量控制。

> 我为什么要这样做？这些信号对于TCP在不可靠的数据报网络上提供流控制，可靠的字节流服务的能力至关重要。 在TCP中，确认表示：“接收器需要多少个下一个字节的索引，以便接收器可以重组更多的ByteStream？” 这告诉发送者它需要发送或重新发送什么字节。流控制意味着，“接收者感兴趣并愿意接收什么范围的索引？” （通常是其剩余容量的函数）。它告诉发件人可以发送多少。

#### ranslating between 64-bit indexes and 32-bit seqnos